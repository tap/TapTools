/*	JSUI javascript for tap.waveform	takes time, amplitude pairs for drawing a waveform		Jesse Allison			TWO IMPROVEMENTS FOR SPEED:	- dump in fewer lists which are longer (i.e. max 200 elements or whatever) 		then process that entire list at once: 1 function call replaces N function calls*/// ** Variable Declarations// ********************************************************************// CONSTANTSconst WAVEFORMUI_VERSION = 2;var numRegions = 1;				// number of selection regions sets # of outletsvar bufferLength = 1000.;		// length of the buffer in msif (jsarguments.length>1)	numRegions = jsarguments[1];if (jsarguments.length>2)	bufferLength = jsarguments[2];inlets = (numRegions + 1);		// 1 inlet for time/amplitude others for region selectionsoutlets = numRegions;setinletassist(0,"list: time, amplitude [0:1]");var i = 0;					// generic looping variablevar myText = ("hi");		// myText = ("RegionColor" + i.toString());				// Textvar myfont = ("Arial");var myfontsize = 9;var mytext = ("0 , 0");var regionColorR = [0.737,0.667,0.667,0.965,0.933];var regionColorG = [0.345,0.761,1.,1.,0.596];var regionColorB = [0.,1.,0.729,0.667,1.];var regionColorA = [1.,1.,1.,1.,1.];	var regionX1 = [0.];		// region areas [-aspect : aspect]var regionX2 = [0.5];var last_x = 0;				// cache mouse position in pixels for tracking delta movementsvar last_y = 0;var listLength = 0;	var selected = 0;var buttonClick = 0;var clicked = 0;sketch.default2d();sketch.glenable(sketch.blend);// sketch.glblendfunc(sketch.zero, sketch.one);// sketch.glblendfunc(sketch.one, sketch.src_alpha);sketch.fsaa = 0;				// antialiasing off by defaultvar boxWidth = box.rect[2] - box.rect[0];		// get window pixel dimentionsvar boxHeight = box.rect[3] - box.rect[1];var aspect = boxWidth / boxHeight;var boxRight = (aspect);var boxLeft = (aspect * -1.);var onePixelWorld = sketch.screentoworld(1,1);var onePixelHighNormalized = (2 / boxHeight);		// find one pixel scaled to 0:1var bufferSize = (bufferLength / (2. * aspect));	// Length of the buffer being addressed calculated in screen sizevar vbrgb = [0.5,0.55,0.73,1.];var scrollPosition = 0.;					// global variable for scroll positionvar lastScroll = (-1. * aspect);var colorWaveform = [0.,0.,0.,1.,];var currentAmplitude = 0.;var scroll = 0.;var amplitudeLow = 0.;var rendersketch = new Sketch(boxWidth,boxHeight);	with (rendersketch) {		default2d();		fsaa=0;		glenable(sketch.blend);		glblendfunc(sketch.one, sketch.src_alpha);		// glblendfunc(sketch.src_alpha, sketch.one);		// glenable("line_smooth");  		// glclearcolor(vbrgb);		// glclear();	}	with (rendersketch) {	glclearcolor(vbrgb);	glclear();}// TIM DID THIS !!!!!!!!!!!!!!!!!!!!!!!function loadbang(){for (i = 0; i < numRegions; i++) {/*	regionColorR[i] = (0.2 + (0.1 * i));	regionColorG[i] = (0.5 + (0.1 * i));	regionColorB[i] = (0.3 + (0.1 * i));	regionColorA[i] = 1.;*/	setoutletassist(i,"list: Region begin, Region end [0:1]"); 		regionX1[i] = (-0.5 + (0.1 * i));			// 2 X Coords in World Coordinates	regionX2[i] = (0.5+ (0.1 * i));}	drawBoxes();	taskMaker();		// start automated refdraw of screen	// drawWaveform();}// ** Functions// ********************************************************************function taskMaker()							// automated screen redrawing.{	var drawTask = new Task(draw);	drawTask.interval = 30; 					// every 60 milliseconds	drawTask.repeat();	 // tsk.repeat(3);// do it 3 times}taskMaker.local = 1;function buffer_size(size){	bufferSize = (size / (2. * aspect));	bufferLength = (size);	draw();	drawWaveform();	refresh();}// ** Drawing// ********************************************************************function draw()				// Draws the region Boxes{		with (sketch) {			glcolor(0.,0.,0.,1.);		copypixels(rendersketch,0,0,0,0,boxWidth,boxHeight);				for (i = 0; i < numRegions; i++) {			// draw regions			if (i == selected) {				glcolor(regionColorR[i],regionColorG[i],regionColorB[i],(regionColorA[i] * 0.4));				quad(regionX1[i], 1.0, 0., regionX2[i], 1.0, 0., regionX2[i], -1.,0., regionX1[i], -1., 0.);				glcolor(regionColorR[i],regionColorG[i],regionColorB[i],regionColorA[i]);				framequad(regionX1[i], 1.0, 0., regionX2[i], 1.0, 0., regionX2[i], -1.,0., regionX1[i], -1., 0.);			} else {				glcolor(regionColorR[i],regionColorG[i],regionColorB[i],(regionColorA[i] * 0.2));				quad(regionX1[i], 1.0, 0., regionX2[i], 1.0, 0., regionX2[i], -1.,0., regionX1[i], -1., 0.);				glcolor(regionColorR[i],regionColorG[i],regionColorB[i],regionColorA[i] * 0.4);				framequad(regionX1[i], 1.0, 0., regionX2[i], 1.0, 0., regionX2[i], -1.,0., regionX1[i], -1., 0.);			}		}	}	drawBoxes();	refresh();}draw.local = 1;						// Draw the current-region selector buttons and the textfunction drawBoxes(){	var h = 0;	var left = 0;	var right = 0;		with (sketch) {		for (i = 0; i < numRegions; i++) {			h = (i + 1);			left = (boxLeft+(i * 0.2));			right = (boxLeft+(h * 0.2));						if (i == selected) {				glcolor(regionColorR[i],regionColorG[i],regionColorB[i],regionColorA[i]);				quad(left,1.,0.,right,1.,0.,right, 0.8, 0., left, 0.8, 0.);				gldisable(sketch.blend);				glcolor(0.,0.,0.,1.);				framequad(left,1.,0.,(right-0.01),1.,0.,(right- 0.01), 0.8, 0., left, 0.8, 0.);				glenable(sketch.blend);								moveto(aspect, 1.0);		// draws X/Y position text				font(myfont);				fontsize(myfontsize);				textalign("right","top");				text(mytext);							} else {				glcolor(vbrgb);				quad(left,1.,0.,right,1.,0.,right, 0.8, 0., left, 0.8, 0.);				glcolor(regionColorR[i],regionColorG[i],regionColorB[i],(regionColorA[i] * 0.5));				quad(left,1.,0.,right,1.,0.,right, 0.8, 0., left, 0.8, 0.);			}		}	}}					// ******* Draw the wave form ********					/*					 *	Gets a list: {x, y}		0.0 < x|y < 1.0					 * 		scrollPosition = x;					 *		currentAmplitude = y;					 *************************************/ function drawWaveform(){	scroll = ((scrollPosition * aspect * 2.) - aspect);	amplitudeLow = (currentAmplitude * -1.);	with (rendersketch) {		if (lastScroll > scroll) {			// if scroll wrapped around, fix ends			glcolor(vbrgb);			quad(lastScroll, 1.0, 0., boxRight, 1.0, 0., boxRight, -1.,0., lastScroll, -1., 0.);			glcolor(colorWaveform);						// update waveform			quad(lastScroll, currentAmplitude, 0., boxRight, currentAmplitude, 0., boxRight, amplitudeLow,0., lastScroll, amplitudeLow, 0.);			lastScroll = boxLeft;		// set lastScroll to far left to finish		}				glcolor(vbrgb);		quad(lastScroll, 1.0, 0., scroll, 1.0, 0., scroll, -1.,0., lastScroll, -1., 0.);		glcolor(colorWaveform);						// update waveform		quad(lastScroll, currentAmplitude, 0., scroll, currentAmplitude, 0., scroll, amplitudeLow,0., lastScroll, amplitudeLow, 0.);			}		lastScroll = scroll;			// draw();  // the task function does this now}// ** Output// ********************************************************************function bang(){								// protect against equaling each other.	if (regionX1[selected] == regionX2[selected]) regionX2[selected] = regionX2[selected] + 0.001;		if (regionX1[selected] <= regionX2[selected]) {		outlet(selected, ((regionX1[selected] + aspect) * bufferSize), ((regionX2[selected] + aspect) * bufferSize));	} else {		outlet(selected, ((regionX2[selected] + aspect) * bufferSize), ((regionX1[selected] + aspect) * bufferSize));	}	/*	for (i = 0; i < numRegions; i++) {		outlet(i, regionX1[i],regionX2[i]);	}	*/}function text()					// Formats the x/y position numbers to display on the screen{	mytext = (((regionX1[selected] / (aspect * 2.) + 0.5) * bufferLength).toFixed(3).toString() + " , " + (((regionX2[selected] / (aspect * 2.)) + 0.5) * bufferLength).toFixed(3).toString());}// ** Input// ********************************************************************function list(){		if (inlet == 0) {		var x = 0;		var y = 0;				listLength = (arguments.length/2);			for (i=0; i < listLength ; i++) {			x = i*2;			y = x+1;						scrollPosition = Math.min(Math.max(0. , arguments[x]), 1.);			currentAmplitude = Math.min(Math.max(onePixelHighNormalized , arguments[y]), 1.);					drawWaveform();		// within the loop, so take care!		}	}			refresh();}function resetScroll(){	lastScroll = (-1.0 * aspect);}function set(start,length){	var whichInlet = (inlet - 1);		// correct for the time/amplitude inlet	// post(start, length, whichInlet, "\n");		if (clicked == 0) {		regionX1[whichInlet] = (start / bufferLength);				// position between 0:1		regionX2[whichInlet] = ((start + length) / bufferLength);	// same				regionX1[whichInlet] = Math.min(Math.max(0.,regionX1[whichInlet]),1.);	// cliped		regionX2[whichInlet] = Math.min(Math.max(0.,regionX2[whichInlet]),1.);				regionX1[whichInlet] = ((regionX1[whichInlet] * (2 * aspect)) - aspect);	// world coords		regionX2[whichInlet] = ((regionX2[whichInlet] * (2 * aspect)) - aspect);				text();	}	}function fsaa(v){	sketch.fsaa = v;	bang();}function brgb(r,g,b,a){	vbrgb[0] = r/255.;	vbrgb[1] = g/255.;	vbrgb[2] = b/255.;	vbrgb[3] = a/255.;	drawWaveform();	refresh();}function setvalueof(v){	}function getvalueof(v){	// return val[v];}// ** Mouse Actions// ********************************************************************function onresize(w,h){	boxWidth = w;	boxHeight = h;	aspect = (boxWidth/boxHeight);		drawWaveform();	refresh();}onresize.local = 1;function onclick(x,y,but,cmd,shift,capslock,option,ctrl){	last_x = x;	last_y = y;	// check to see if button is clicked.	buttonClick = 0;	var world = sketch.screentoworld(x,y);			// World coords for x/y click		for (i = 0; i < numRegions; i++) {				// cycle through # of regions checking if boxes clicked		h = (i + 1);		left = (boxLeft+(i * 0.2));		right = (boxLeft+(h * 0.2));			if ((world[0] >= left) && (world[0] <= right) && (world[1] >= 0.8)) {			selected = i;			buttonClick = 1;		}			}													// otherwise set new selection values	if (buttonClick != 1) {			// if clicked not on box		// regionX1[selected] = Math.min(Math.max(boxLeft, world[0]), boxRight);												// if clicked outside selection, move selection to that point		if ((world[0] < regionX1[selected]) || (world[0] > regionX2[selected])) {			dx = (world[0] - regionX1[selected] + ((regionX1[selected] - regionX2[selected]) * 0.5));		// change in world coords			regionX1[selected] = Math.min(Math.max(boxLeft, (regionX1[selected] + dx)), boxRight);	// move X1 & X2 the appropriate amount			regionX2[selected] = Math.min(Math.max(boxLeft, (regionX2[selected] + dx)), boxRight);		}				ondrag(x,y);			} else {						// if clicked on a box		// drawWaveform();		text();		bang();	}}onclick.local = 1;function ondrag(x,y,but,cmd,shift,capslock,option,ctrl){		// drag for the 2nd x value	if (buttonClick == 0) {				var scaleVal = [0.01, 1.0];			// scaling for [width, x position]		if (shift) {			scaleVal = [0.001, 0.02];		}				// This is the preliminary xy draging adjustment.			dx = x - last_x;					// change in x		dy = y - last_y;					// change in y		dx = (dx / boxWidth) * 2 * aspect;		// translate into change in world coords																// x = x±ychange + (change in x)		regionX1[selected] = (regionX1[selected] + (dy * scaleVal[0])) + (dx * scaleVal[1]);		regionX1[selected] = Math.min(Math.max(boxLeft, regionX1[selected]), regionX2[selected]);				regionX2[selected] = (regionX2[selected] - (dy * scaleVal[0])) + (dx * scaleVal[1]);		regionX2[selected] = Math.min(Math.max(regionX1[selected], regionX2[selected]), boxRight);				last_x = x;				// cache mouse position for tracking delta movements		last_y = y;				text();		bang();		// draw();  // now done by the task.		refresh();	}}ondrag.local = 1;